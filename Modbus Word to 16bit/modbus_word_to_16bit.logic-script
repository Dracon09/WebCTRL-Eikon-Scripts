// =============================================================
// Map a Modbus word to 16 Bits 
// 
// V6.4.6 - 02-12-2026
// Tested on WC 10.0
// =============================================================

def CONFIG = [
    // --- ALARM CONFIGURATION ---
    enableAlarms      : true,
    potentialSource   : true,             // [Potential alarm source]
    isCritical        : true,             // [Critical]
    alarmCategory     : "hvac_critical",  // [Category] use approved tokens to avoid creating new ones
    alarmEnabled      : 1,                // [Alarm Enable] (1 or 0 / true or false)
    delaySeconds      : 0,                // [Delay Seconds] (optional if supported)
    alarmText         : "\$source\$ is in alarm.",            // optional
    alarmAckRequired  : false,            // [Alarm requires acknowledge]
    returnEnabled     : 0,                // [Return Enabled] (1 or 0 / true or false)
    returnText        : "\$source\$ has returned to normal.", // optional
    returnAckRequired : false,            // [Return requires acknowledge]
    // template       : "Universal",      // If your event supports a 'template' property

    // --- TREND CONFIGURATION ---
    enableTrends      : true,
    enableLog         : true,             // [Enable Trend Log]
    sampleOnCOV       : true,             // [Sample on COV]
    sampleInterval    : 300000,           // [Sample every] in ms (default 00:05:00 = 300,000ms)
    maxSamples        : 100,              // [Max samples]
    enableHistorian   : true,             // [Enable Trend Historian]
    keepHistoryDays   : 0,                // [Keep historical trends for]
    useDefaultThresh  : true,             // [Use default (45% of Max samples)]
    writeEverySamples : 45                // [Write to historian every N samples] used when useDefaultThresh=false
]

// -------------------------------------------------------------
import javax.swing.*
import javax.swing.table.*
import java.awt.*
import java.awt.event.*
import java.awt.datatransfer.*
import java.net.URLDecoder
import java.util.regex.Pattern
import java.util.regex.Matcher

// --- 1) FILE & PATH RESOLUTION (Prefer extra/extras; no hardcoding) ---

def getBaseDir = {
    try {
        def url = getClass().protectionDomain?.codeSource?.location
        if (url != null) {
            def p = URLDecoder.decode(url.path, "UTF-8")
            File loc = new File(p)
            if (loc.isFile()) return loc.parentFile
            if (loc.isDirectory()) return loc
        }
    } catch (Throwable ignore) {}
    try {
        def wd = System.getProperty("user.dir")
        if (wd) {
            File f = new File(wd)
            if (f.exists()) return f
        }
    } catch (Throwable ignore) {}
    return new File(".").canonicalFile
}()

def candidateDirs = {
    def list = []
    def base = getBaseDir
    def parent = base?.parentFile
    list << base
    list << new File(base, "extra")
    list << new File(base, "extras")
    if (parent != null) {
        list << parent
        list << new File(parent, "extra")
        list << new File(parent, "extras")
    }
    try {
        def wd = System.getProperty("user.dir", ".")
        list << new File(wd)
    } catch (Throwable ignore) {}
    list << new File(".")
    return list.findAll { it != null }
               .collect { it.canonicalFile }
               .unique()
}()

def resolveAsset = { String fileName ->
    for (File dir : candidateDirs) {
        File f = new File(dir, fileName)
        if (f.exists()) return f
    }
    File preferred = new File(getBaseDir, "extra")
    if (!preferred.exists()) preferred = new File(getBaseDir, "extras")
    if (!preferred.exists()) preferred = getBaseDir
    return new File(preferred, fileName)
}

// Use asset-relative files (no hardcoded WebCTRL paths)
def symbolFile = resolveAsset("modbus_word_to_16bit.logicsymbol")
def csvFile    = resolveAsset("NamingRules.csv")

// --- 2) HELPERS: names, regex-safe replaces, time conversion ---

def makeRefSafe = { String s ->
    if (!s) return ""
    s = s.toLowerCase()
         .replaceAll("[^a-z0-9]", "_")
         .replaceAll("_{2,}", "_")
         .replaceAll("^_|_\$", "")
    if (s.matches("^\\d.*")) s = "_" + s
    return s 
}

def replaceAllLiteral = { String input, String find, String repl ->
    if (input == null) return null
    input.replaceAll(Pattern.quote(find), Matcher.quoteReplacement(repl))
}
def replaceAllLiteralIgnoreCase = { String input, String find, String repl ->
    if (input == null) return null
    input.replaceAll("(?i)" + Pattern.quote(find), Matcher.quoteReplacement(repl))
}

// Time helpers (hh:mm:ss <-> ms)
def msToHHMMSS = { long ms ->
    if (ms < 0) ms = 0
    long totalSec = Math.round(ms / 1000.0)
    long h = totalSec.intdiv(3600)
    long m = (totalSec % 3600).intdiv(60)
    long s = totalSec % 60
    String.format("%02d:%02d:%02d", h, m, s)
}
def hhmmssToMs = { String s ->
    if (!s) return 0
    def m = s.trim() =~ /^(?i)\s*(\d{1,2}):(\d{1,2}):(\d{1,2})\s*$/
    if (m.matches()) {
        int h = Integer.parseInt(m[0][1])
        int mi = Integer.parseInt(m[0][2])
        int se = Integer.parseInt(m[0][3])
        return (h*3600 + mi*60 + se) * 1000
    }
    // Accept mm:ss
    m = s.trim() =~ /^\s*(\d{1,2}):(\d{1,2})\s*$/
    if (m.matches()) {
        int mi = Integer.parseInt(m[0][1])
        int se = Integer.parseInt(m[0][2])
        return (mi*60 + se) * 1000
    }
    // Accept integer minutes
    try { return Integer.parseInt(s.trim()) * 60 * 1000 } catch (Throwable ignore) {}
    return 0
}

// --- 3) Rename tracker, naming rules ---

class RenameTracker {
    def script
    def pending = [:]
    int count = 0
    RenameTracker(s) { this.script = s }
    private String nextTmp() { "tmp_bit_${System.currentTimeMillis()}_${count++}" }
    def stage(label, finalName) {
        if (label?.name == finalName) return
        String tmp = nextTmp()
        pending[tmp] = finalName
        label.rename(tmp)
    }
    def commit() {
        pending.each { tmp, fin -> try { script.logic.labels(tmp).rename(fin) } catch(e) {} }
        pending.clear(); count = 0
    }
}
def tracker = new RenameTracker(this)
def shortenMap = [:]

def loadNamingRules = {
    shortenMap.clear()
    if (csvFile.exists()) {
        csvFile.eachLine { line ->
            if (!line?.trim() || line.startsWith("#")) return
            def p = line.split(',')
            if (p.size() == 2) shortenMap.put(p[0].trim(), p[1].trim())
        }
    }
}
loadNamingRules()

def eikonFormatRef = { str ->
    if (!str) return ""
    def s = str
    shortenMap.each { k, v ->
        s = s.replaceAll("(?i)\\b" + Pattern.quote(k) + "\\b", Matcher.quoteReplacement(v))
    }
    return makeRefSafe(s)
}

// --- 4) UI: table + fields ---

class EikonCellRenderer extends DefaultTableCellRenderer {
    @Override
    Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int col) {
        Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, col)
        String text = value ? value.toString() : ""
        c.setBackground(isSelected ? table.getSelectionBackground() : Color.WHITE)
        c.setForeground(isSelected ? table.getSelectionForeground() : Color.BLACK)
        if (col == 1 && text.length() > 40) {
            c.setForeground(Color.RED); c.setFont(c.getFont().deriveFont(Font.BOLD))
        } else if (col == 2) {
            if (text.length() > 40) c.setBackground(new Color(255, 100, 100))
            else if (text.length() > 36) c.setBackground(new Color(255, 255, 150))
        }
        return c
    }
}

def columnNames = ["Bit", "Display Name", "Reference Name"]
def data = (0..15).collect { [it.toString(), "", ""] } as Object[][]
DefaultTableModel model = new DefaultTableModel(data, columnNames as Object[]) { @Override boolean isCellEditable(int r, int c) { return c != 0 } }
JTable table = new JTable(model)
table.setDefaultRenderer(Object.class, new EikonCellRenderer())
table.setRowHeight(22)
table.getColumnModel().getColumn(0).setMaxWidth(40)
table.setCellSelectionEnabled(true)

// COPY/PASTE
table.addKeyListener(new KeyAdapter() {
    @Override
    void keyPressed(KeyEvent e) {
        int mask
        try { mask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx() }
        catch (Throwable t) { try { mask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMask() } catch (Throwable t2) { mask = java.awt.event.InputEvent.CTRL_DOWN_MASK } }
        if ((e.getModifiersEx() & mask) != 0 && e.getKeyCode() == KeyEvent.VK_C) {
            StringBuilder sbf = new StringBuilder()
            int[] rows = table.getSelectedRows(); int[] cols = table.getSelectedColumns()
            for (int r : rows) {
                for (int c : cols) {
                    def val = table.getValueAt(r, c)
                    sbf.append(val == null ? "" : val.toString())
                    if (c != cols[cols.length-1]) sbf.append("\t")
                }
                sbf.append("\n")
            }
            StringSelection sel = new StringSelection(sbf.toString())
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(sel, sel)
            e.consume()
        }
        if ((e.getModifiersEx() & mask) != 0 && e.getKeyCode() == KeyEvent.VK_V) {
            int rStart = table.getSelectedRow() == -1 ? 0 : table.getSelectedRow()
            int cStart = table.getSelectedColumn() == -1 ? 1 : table.getSelectedColumn()
            try {
                String cb = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null).getTransferData(DataFlavor.stringFlavor)
                cb.split("\\r?\\n").eachWithIndex { line, i ->
                    if (!line?.trim()) return
                    if ((rStart + i) < 16) {
                        String[] cells = line.split("\t")
                        cells.eachWithIndex { val, j ->
                            if ((cStart + j) < 3 && (cStart + j) > 0) model.setValueAt((val == null) ? "" : val.trim(), rStart + i, cStart + j)
                        }
                    }
                }
            } catch (Exception ex) { /* ignore */ }
            e.consume()
        }
    }
})

model.addTableModelListener({ e ->
    if (e.getType() == 0 && (e.getColumn() == 1)) {
        int r = e.getFirstRow()
        Object val = model.getValueAt(r, 1)
        if (val != null) SwingUtilities.invokeLater({ model.setValueAt(eikonFormatRef(val.toString()), r, 2) })
    }
} as javax.swing.event.TableModelListener)

// Basic fields
JTextField oldRegField = new JTextField("898989898", 10)
JTextField newRegField = new JTextField("", 10)
JTextArea statusLabel = new JTextArea("", 4, 50)
statusLabel.setEditable(false); statusLabel.setBackground(new Color(240, 240, 240))

// Make the main frame visible to all closures / actions (assign later)
def frame  // critical for dialogs if any

// Compute "Assets Dir"
def assetsDir = null
try {
    def sDir = symbolFile?.parentFile?.canonicalFile
    def cDir = csvFile?.parentFile?.canonicalFile
    if (sDir != null && sDir == cDir) assetsDir = sDir
} catch (Throwable ignore) {}
statusLabel.setText(
    "Ready\n" +
    "V6.4.6 - Script-relative paths & hardening\n" +
    (assetsDir ? "Assets Dir: ${assetsDir?.absolutePath}\nSymbol: ${symbolFile?.name}\nRules CSV: ${csvFile?.name}"
               : "Symbol: ${symbolFile?.absolutePath}\nRules CSV: ${csvFile?.absolutePath}\nBase Dir: ${getBaseDir?.absolutePath}")
)

// --- 5) MENU (keep naming rules utilities) ---
JMenuBar menuBar = new JMenuBar()
JMenu editMenu = new JMenu("Edit")
JMenuItem editCsvItem = new JMenuItem("Edit Naming Rules...")
JMenuItem reloadCsvItem = new JMenuItem("Reload Naming Rules")

editCsvItem.addActionListener({ 
    if (csvFile.exists()) Desktop.getDesktop().edit(csvFile)
    else JOptionPane.showMessageDialog(null, "File not found: " + csvFile.absolutePath)
} as ActionListener)

reloadCsvItem.addActionListener({ 
    loadNamingRules()
    for (int i=0; i<16; i++) { 
        def dObj = model.getValueAt(i, 1)
        String d = (dObj == null) ? "" : dObj.toString()
        if (d) model.setValueAt(eikonFormatRef(d), i, 2) 
    }
    statusLabel.setText("Rules reloaded.")
} as ActionListener)

editMenu.add(editCsvItem)
editMenu.add(reloadCsvItem)
menuBar.add(editMenu)

// --- 6) TABS ---
// Default WebCTRL 10.0 tokens — used in the Category dropdown
def DEFAULT_ALARM_CATEGORIES = [
    "other",
    "accesscontrol_critical", "accesscontrol_general", "accesscontrol_maintenance",
    "electricpower_critical", "electricpower_general", "electricpower_maintenance",
    "firesystem_critical", "firesystem_general", "firesystem_maintenance",
    "hvac_critical", "hvac_general", "hvac_maintenance",
    "fdd_comfort", "fdd_critical", "fdd_energy", "fdd_general",
    "lightingsystem_critical", "lightingsystem_general", "lightingsystem_maintenance",
    "general_alarm", "general_message", "unknown"
]

// Pretty display for category tokens
def prettify = { String t ->
    if (!t) return ""
    t.replace('_',' ').split(' ').collect { it.length()>0 ? it[0].toUpperCase()+it.substring(1) : it }.join(' ')
            .replace("Hvac","HVAC")
}

JTabbedPane tabs = new JTabbedPane()

// ----- 16bit Tab (default) -----
JPanel mappingPanel = new JPanel(new BorderLayout(5,5))
mappingPanel.add(new JScrollPane(table), BorderLayout.CENTER)

// Reg fields under the table (inside 16bit tab)
JPanel regPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 12, 6))
regPanel.add(new JLabel("Symbol Reg#:")); regPanel.add(oldRegField)
regPanel.add(new JLabel("Target Reg#:")); regPanel.add(newRegField)
mappingPanel.add(regPanel, BorderLayout.SOUTH)

// ----- Alarm Tab -----
JPanel alarmPanel = new JPanel(new GridBagLayout())
GridBagConstraints agbc = new GridBagConstraints()
agbc.insets = new Insets(4,6,4,6); agbc.anchor = GridBagConstraints.WEST; agbc.fill = GridBagConstraints.HORIZONTAL
agbc.weightx = 0; agbc.gridx = 0; agbc.gridy = 0

JCheckBox chkPotential = new JCheckBox("Potential alarm source", CONFIG.potentialSource)
JCheckBox chkCritical  = new JCheckBox("Critical", CONFIG.isCritical)
JComboBox<String> cmbCategory = new JComboBox<>(DEFAULT_ALARM_CATEGORIES as String[])
cmbCategory.setEditable(false)
cmbCategory.setRenderer(new DefaultListCellRenderer() {
    @Override Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus) {
        super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus)
        setText(prettify(value?.toString()))
        return this
    }
})
if (CONFIG.alarmCategory && DEFAULT_ALARM_CATEGORIES.contains(CONFIG.alarmCategory)) {
    cmbCategory.setSelectedItem(CONFIG.alarmCategory)
}
JCheckBox chkAlarmEnabled = new JCheckBox("Alarm Enable", (CONFIG.alarmEnabled instanceof Boolean) ? CONFIG.alarmEnabled : (CONFIG.alarmEnabled==1))
JTextField txtDelaySec    = new JTextField(String.valueOf(CONFIG.delaySeconds ?: 0), 6)
JTextArea  txtAlarmText   = new JTextArea(CONFIG.alarmText ?: "", 3, 40)
JCheckBox chkAckReq       = new JCheckBox("Alarm requires acknowledge", CONFIG.alarmAckRequired)
JCheckBox chkReturnEn     = new JCheckBox("Return Enabled", (CONFIG.returnEnabled instanceof Boolean) ? CONFIG.returnEnabled : (CONFIG.returnEnabled==1))
JTextArea  txtReturnText  = new JTextArea(CONFIG.returnText ?: "", 3, 40)
JCheckBox chkReturnAckReq = new JCheckBox("Return requires acknowledge", CONFIG.returnAckRequired)

def addA = { Component c, int x, int y, int wx=1 ->
    agbc.gridx=x; agbc.gridy=y; agbc.weightx=wx; alarmPanel.add(c, agbc)
}
addA(new JLabel(""), 0,0)
addA(chkPotential, 0,1)
addA(chkCritical,  0,2)
addA(new JLabel("Category"), 0,3,0); addA(cmbCategory, 1,3,1)
addA(new JLabel("Alarm"), 0,4,0)
addA(chkAlarmEnabled, 0,5)
addA(new JLabel("Delay Seconds"), 0,6,0); addA(txtDelaySec, 1,6,1)
addA(new JLabel("Alarm text"), 0,7,0); addA(new JScrollPane(txtAlarmText), 1,7,1)
addA(chkAckReq, 0,8)
addA(new JLabel("Return to Normal"), 0,9,0)
addA(chkReturnEn, 0,10)
addA(new JLabel("Return text"), 0,11,0); addA(new JScrollPane(txtReturnText), 1,11,1)
addA(chkReturnAckReq, 0,12)

// ----- Trend Tab -----
JPanel trendPanel = new JPanel(new GridBagLayout())
GridBagConstraints tgbc = new GridBagConstraints()
tgbc.insets = new Insets(4,6,4,6); tgbc.anchor = GridBagConstraints.WEST; tgbc.fill = GridBagConstraints.HORIZONTAL
tgbc.weightx = 0; tgbc.gridx = 0; tgbc.gridy = 0

JCheckBox chkEnableLog   = new JCheckBox("Enable Trend Log", CONFIG.enableLog)
JRadioButton rbInterval  = new JRadioButton("Sample every (hh:mm:ss)")
JTextField  txtInterval  = new JTextField(msToHHMMSS(CONFIG.sampleInterval as long), 10)
JRadioButton rbCOV       = new JRadioButton("Sample on COV (change of value)")
ButtonGroup grpSample    = new ButtonGroup(); grpSample.add(rbInterval); grpSample.add(rbCOV)
if (CONFIG.sampleOnCOV) rbCOV.setSelected(true) else rbInterval.setSelected(true)
JTextField  txtMaxSamples = new JTextField(String.valueOf(CONFIG.maxSamples ?: 100), 6)
JCheckBox chkEnableHist   = new JCheckBox("Enable Trend Historian", CONFIG.enableHistorian)
JTextField txtKeepDays    = new JTextField(String.valueOf(CONFIG.keepHistoryDays ?: 0), 6)
JRadioButton rbUseEvery   = new JRadioButton("Write to historian: Every")
JTextField  txtEvery      = new JTextField(String.valueOf(CONFIG.writeEverySamples ?: 45), 6)
JLabel      lblEveryTail  = new JLabel("trend samples (must be ≤ Max samples)")
JRadioButton rbUseDefault = new JRadioButton("Use default (45% of Max samples)")
ButtonGroup grpThresh     = new ButtonGroup(); grpThresh.add(rbUseEvery); grpThresh.add(rbUseDefault)
if (CONFIG.useDefaultThresh) { rbUseDefault.setSelected(true) } else { rbUseEvery.setSelected(true) }

def addT = { Component c, int x, int y, int wx=1 ->
    tgbc.gridx=x; tgbc.gridy=y; tgbc.weightx=wx; trendPanel.add(c, tgbc)
}
addT(chkEnableLog, 0,0)
addT(rbInterval, 0,1,0); addT(txtInterval, 1,1,0)
addT(rbCOV, 0,2)
addT(new JLabel("Max samples"), 0,3,0); addT(txtMaxSamples, 1,3,0)
addT(chkEnableHist, 0,4)
addT(new JLabel("Keep historical trends for (days)"), 0,5,0); addT(txtKeepDays, 1,5,0)
addT(rbUseEvery, 0,6,0)
addT(txtEvery, 1,6,0); addT(lblEveryTail, 2,6,1)
addT(rbUseDefault, 0,7,0)

// Add tabs (16bit first, default)
tabs.addTab("16bit", mappingPanel)
tabs.addTab("Alarm", new JScrollPane(alarmPanel))
tabs.addTab("Trend", new JScrollPane(trendPanel))
tabs.setSelectedIndex(0)

// Helper: push tab fields -> CONFIG
def applyTabsToConfig = {
    // Alarm
    CONFIG.potentialSource   = chkPotential.isSelected()
    CONFIG.isCritical        = chkCritical.isSelected()
    CONFIG.alarmCategory     = (cmbCategory.getSelectedItem()?.toString() ?: CONFIG.alarmCategory)
    CONFIG.alarmEnabled      = chkAlarmEnabled.isSelected() ? 1 : 0
    try { CONFIG.delaySeconds = Integer.parseInt(txtDelaySec.getText().trim()) } catch (Throwable ignore) { CONFIG.delaySeconds = 0 }
    CONFIG.alarmText         = txtAlarmText.getText()
    CONFIG.alarmAckRequired  = chkAckReq.isSelected()
    CONFIG.returnEnabled     = chkReturnEn.isSelected() ? 1 : 0
    CONFIG.returnText        = txtReturnText.getText()
    CONFIG.returnAckRequired = chkReturnAckReq.isSelected()

    // Trend
    CONFIG.enableLog       = chkEnableLog.isSelected()
    CONFIG.sampleOnCOV     = rbCOV.isSelected()
    CONFIG.sampleInterval  = hhmmssToMs(txtInterval.getText())
    try { CONFIG.maxSamples = Integer.parseInt(txtMaxSamples.getText().trim()) } catch (Throwable ignore) { /* keep */ }
    CONFIG.enableHistorian = chkEnableHist.isSelected()
    try { CONFIG.keepHistoryDays = Integer.parseInt(txtKeepDays.getText().trim()) } catch (Throwable ignore) { /* keep */ }
    CONFIG.useDefaultThresh = rbUseDefault.isSelected()
    try { CONFIG.writeEverySamples = Integer.parseInt(txtEvery.getText().trim()) } catch (Throwable ignore) { /* keep */ }
}

// --- 7) BOTTOM CONTROLS (status + buttons) ---
JButton okButton = new JButton("OK")
JButton swapButton = new JButton("Swap Bits")
JButton fixOCRButton = new JButton("Fix OCR")
JButton clearButton = new JButton("Clear Labels")
JButton cancelButton = new JButton("Close")

JPanel buttonPanel = new JPanel(); 
buttonPanel.add(okButton); buttonPanel.add(swapButton); buttonPanel.add(fixOCRButton); 
buttonPanel.add(clearButton); buttonPanel.add(cancelButton)

JPanel bottomPanel = new JPanel(); 
bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS))
bottomPanel.add(new JScrollPane(statusLabel) {{ setPreferredSize(new Dimension(600, 90)) }})
bottomPanel.add(buttonPanel)

// --- 8) MAIN LAYOUT: tabs center, bottom status/buttons ---
JPanel mainPanel = new JPanel(new BorderLayout(5, 5)); 
mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
mainPanel.add(tabs, BorderLayout.CENTER)
mainPanel.add(bottomPanel, BorderLayout.SOUTH)

// --- 9) FRAME ---
def frameTitle = "Modbus Word to 16 bit Mapping V6.4.6"
frame = new JFrame(frameTitle)
frame.setJMenuBar(menuBar)
frame.setContentPane(mainPanel); frame.pack(); frame.setLocationRelativeTo(null); frame.setAlwaysOnTop(true)
frame.setVisible(true)

// --- 10) BUTTON ACTIONS ---

swapButton.addActionListener({ 
    Object[][] temp = new Object[16][2]; 
    for (int i = 0; i < 16; i++) { 
        temp[i][0] = model.getValueAt(i, 1); 
        temp[i][1] = model.getValueAt(i, 2) 
    }
    for (int i = 0; i < 16; i++) { 
        model.setValueAt(temp[15-i][0], i, 1); 
        model.setValueAt(temp[15-i][1], i, 2) 
    }
} as ActionListener)

fixOCRButton.addActionListener({ 
    for (int i = 0; i < 16; i++) { 
        def obj = model.getValueAt(i, 1)
        String n = (obj == null) ? "" : obj.toString()
        if (n) model.setValueAt(n.replaceAll("(?<=[a-z0-9])(?=[A-Z])", " ").trim(), i, 1) 
    }
} as ActionListener)

clearButton.addActionListener({ 
    for (int i = 0; i < 16; i++) { 
        model.setValueAt("", i, 1); 
        model.setValueAt("", i, 2) 
    } 
} as ActionListener)

cancelButton.addActionListener({ frame.dispose() } as ActionListener)

// --- 11) OK handler (applies tabbed CONFIG first, then logic) ---

okButton.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent eventObj) {
        try {
            applyTabsToConfig() // <-- read values from tabs into CONFIG

            def oldR = oldRegField.getText()?.trim()
            def newR = newRegField.getText()?.trim()
            if (!newR) { statusLabel.setText("Target Reg Required"); return }

            // Append logic symbol (if present)
            if (symbolFile?.exists()) {
                logic.append { symbol(symbolFile.absolutePath) { } }
            }

            // Update text figures & labels (literal-safe)
            logic.figures { 
                if (getType()=='text-figure' && text?.contains(oldR)) {
                    text = replaceAllLiteral(text, oldR, newR)
                }
            }
            logic.labels().each { 
                def nm = it?.name
                if (nm?.contains(oldR)) tracker.stage(it, replaceAllLiteral(nm, oldR, newR))
            }

            // Update microblocks - global oldR->newR
            logic.microblocks {
                if (propNames.contains('address')) {
                    def addr = prop.'address'
                    if (addr instanceof String && addr.contains(oldR)) prop.'address' = replaceAllLiteral(addr, oldR, newR)
                }
                if (propNames.contains('display name')) {
                    def dn = prop.'display name'
                    if (dn instanceof String && dn.contains(oldR)) prop.'display name' = replaceAllLiteral(dn, oldR, newR)
                }
                if (propNames.contains('reference name')) {
                    def rn = prop.'reference name'
                    if (rn instanceof String && rn.toLowerCase().contains(oldR.toLowerCase())) {
                        prop.'reference name' = makeRefSafe(replaceAllLiteralIgnoreCase(rn, oldR, newR))
                    }
                }
            }

            tracker.commit()

            // Per-bit updates based on "pb_<newR>_<00..15>" hooks
            for (int i = 0; i < 16; i++) {
                String dName = (model.getValueAt(i, 1) ?: "").toString().trim()
                String rBase = (model.getValueAt(i, 2) ?: "").toString().trim()
                if (!dName) continue

                String hook = "pb_${newR}_" + String.format("%02d", i)

                logic.microblocks {
                    if (prop.'reference name'?.contains(hook)) {
                        // Display & description
                        prop.'display name' = dName
                        if (propNames.contains('description')) prop.'description' = dName
                        
                        // --- ALARMS (from CONFIG) ---
                        if (type == 'event' && CONFIG.enableAlarms) {
                            if (propNames.contains('potential alarm source')) prop.'potential alarm source' = CONFIG.potentialSource
                            if (propNames.contains('critical'))               prop.'critical' = CONFIG.isCritical
                            if (propNames.contains('category'))               try { prop.'category' = CONFIG.alarmCategory } catch(ex) {}
                            if (propNames.contains('alarm enabled')) {
                                def val = CONFIG.alarmEnabled
                                try { prop.'alarm enabled' = val } catch(ex) { try { prop.'alarm enabled' = (val==1) } catch(ex2) { prop.'alarm enabled' = "${val}" } }
                            }
                            if (propNames.contains('delay seconds'))          try { prop.'delay seconds' = (CONFIG.delaySeconds ?: 0) } catch(ex) {}
                            if (CONFIG.alarmText && propNames.contains('alarm text'))   prop.'alarm text' = CONFIG.alarmText
                            if (propNames.contains('alarm requires acknowledge'))       prop.'alarm requires acknowledge' = CONFIG.alarmAckRequired
                            if (propNames.contains('return enabled')) {
                                def rval = CONFIG.returnEnabled
                                try { prop.'return enabled' = rval } catch(ex) { try { prop.'return enabled' = (rval==1) } catch(ex2) { prop.'return enabled' = "${rval}" } }
                            }
                            if (CONFIG.returnText && propNames.contains('return text')) prop.'return text' = CONFIG.returnText
                            if (propNames.contains('return requires acknowledge'))      prop.'return requires acknowledge' = CONFIG.returnAckRequired
                            if (CONFIG.template && propNames.contains('template')) {
                                try { prop.'template' = CONFIG.template } catch (Throwable ignore) {}
                            }
                        }
                        
                        // --- TRENDS (from CONFIG) ---
                        if ((type == 'bdt' || type == 'bat') && CONFIG.enableTrends) {
                            if (propNames.contains('enable trend log')) {
                                def lval = CONFIG.enableLog
                                try { prop.'enable trend log' = lval } 
                                catch(ex) { try { prop.'enable trend log' = (lval?1:0) } 
                                catch(ex2) { prop.'enable trend log' = "${lval?1:0}" } }
                            }
                            if (propNames.contains('enable trend historian')) prop.'enable trend historian' = CONFIG.enableHistorian
                            if (propNames.contains('allocate memory for'))   prop.'allocate memory for' = CONFIG.maxSamples
                            if (propNames.contains('keep historical trends for')) prop.'keep historical trends for' = CONFIG.keepHistoryDays

                            // Prefer boolean COV flag
                            if (propNames.contains('sample on COV')) {
                                try { prop.'sample on COV' = CONFIG.sampleOnCOV } catch (Throwable ignore) {}
                            }
                            if (!CONFIG.sampleOnCOV && propNames.contains('sample every')) {
                                try { prop.'sample every' = (CONFIG.sampleInterval ?: 300000) } catch (Throwable ignore) {}
                            }

                            // Historian write threshold
                            if (propNames.contains('use trend notification threshold')) {
                                prop.'use trend notification threshold' = CONFIG.useDefaultThresh
                            }
                            if (!CONFIG.useDefaultThresh) {
                                if (propNames.contains('write to historian every')) {
                                    try { prop.'write to historian every' = CONFIG.writeEverySamples } catch (Throwable ignore) {}
                                } else if (propNames.contains('write to historian')) {
                                    try { prop.'write to historian' = CONFIG.writeEverySamples } catch (Throwable ignore) {}
                                } else if (propNames.contains('trend notification threshold')) {
                                    try { prop.'trend notification threshold' = CONFIG.writeEverySamples } catch (Throwable ignore) {}
                                }
                            }

                            if (CONFIG.containsKey('activeText') && propNames.contains('active text'))      
                                prop.'active text' = CONFIG.activeText
                            if (CONFIG.containsKey('inactiveText') && propNames.contains('inactive text'))    
                                prop.'inactive text' = CONFIG.inactiveText
                        }

                        // Ensure suffix on reference name
                        String targetSuffix = (type == "bat" || type == "bdt") ? "_tnd" : (type == "event" ? "_alm" : "_bv")
                        if (propNames.contains('reference name')) {
                            String rb = rBase ?: ""
                            String withSfx = rb.endsWith(targetSuffix) ? rb : (rb + targetSuffix)
                            prop.'reference name' = makeRefSafe(withSfx)
                        }
                    }
                }
            }

            statusLabel.setText("Success: Register ${newR} updated.")
        } catch (Exception ex) { 
            statusLabel.setText("Error: " + (ex?.message ?: ex?.toString()))
        }
    }
})
